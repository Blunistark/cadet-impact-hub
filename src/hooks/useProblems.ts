import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/lib/supabaseClient';
import type { Problem as ProblemTypeFromSchema, Profile } from '@/shared/schema'; // Using Drizzle schema types for now
import { PostgrestError } from '@supabase/supabase-js';

// Define a more specific Problem type for frontend use, including the expanded profile
export interface ProblemWithProfile extends Omit<ProblemTypeFromSchema, 'postedBy' | 'approvedBy'> {
  posted_by: string; // UUID
  approved_by: string | null; // UUID or null
  profiles: Pick<Profile, 'id' | 'full_name' | 'role'> | null; // Embedded profile for who posted
  // We might also want approved_by_profile if needed later:
  // approved_by_profiles: Pick<Profile, 'id' | 'full_name' | 'role'> | null;
}


// Data for creating a new problem
export interface CreateProblemData {
  title: string;
  description: string;
  location: string;
  tags?: string[];
  priority?: 'low' | 'medium' | 'high';
  level?: 'level1' | 'level2' | 'level3';
  posted_by: string; // User ID (UUID) of the poster
  // status will default to 'pending' in the database
}

// Data for updating an existing problem
export interface UpdateProblemData {
  id: string; // Problem ID (UUID)
  title?: string;
  description?: string;
  location?: string;
  tags?: string[];
  status?: 'pending' | 'approved' | 'rejected';
  priority?: 'low' | 'medium' | 'high';
  level?: 'level1' | 'level2' | 'level3';
  approval_feedback?: string;
  approved_by?: string | null; // User ID (UUID) of the approver
}


export const useProblems = () => {
  return useQuery<ProblemWithProfile[], PostgrestError>({
    queryKey: ['problems'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('problems')
        .select(`
          *,
          profiles ( id, full_name, role )
        `)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching problems:', error);
        throw error;
      }
      // The 'profiles' foreign table will be aliased to 'profiles' if the foreign key is to profiles.id
      // If the foreign key column name is `posted_by` that references `profiles.id`,
      // Supabase will nest the profile data under a key named `profiles` if not aliased.
      // Let's adjust the type if needed based on actual Supabase response.
      // For now, assuming 'profiles' is the key for the related posted_by user.
      return data as ProblemWithProfile[];
    },
  });
};

export const useCreateProblem = () => {
  const queryClient = useQueryClient();

  return useMutation<ProblemTypeFromSchema, PostgrestError, CreateProblemData>({
    mutationFn: async (problemData: CreateProblemData) => {
      const problemToInsert = {
        ...problemData,
        // id is generated by default by `uuid_generate_v4()` in the DB via `uuid()` in schema
      };

      const { data, error } = await supabase
        .from('problems')
        .insert(problemToInsert)
        .select()
        .single(); // Assuming you want the created problem back

      if (error) {
        console.error('Error creating problem:', error);
        throw error;
      }
      return data as ProblemTypeFromSchema;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['problems'] });
    },
  });
};

export const useUpdateProblem = () => {
  const queryClient = useQueryClient();

  return useMutation<ProblemTypeFromSchema, PostgrestError, UpdateProblemData>({
    mutationFn: async (problemUpdateData: UpdateProblemData) => {
      const { id, ...updateFields } = problemUpdateData;

      const { data, error } = await supabase
        .from('problems')
        .update({ ...updateFields, updated_at: new Date().toISOString() })
        .eq('id', id)
        .select()
        .single(); // Assuming you want the updated problem back

      if (error) {
        console.error('Error updating problem:', error);
        throw error;
      }
      return data as ProblemTypeFromSchema;
    },
    onSuccess: (_data, variables) => {
      // Invalidate all problems
      queryClient.invalidateQueries({ queryKey: ['problems'] });
      // Optionally, invalidate specific problem query if you have one
      // queryClient.invalidateQueries({ queryKey: ['problem', variables.id] });
    },
  });
};

// Optional: Hook to fetch a single problem if needed
export const useProblemById = (id: string | undefined) => {
  return useQuery<ProblemWithProfile | null, PostgrestError>({
    queryKey: ['problem', id],
    queryFn: async () => {
      if (!id) return null;
      const { data, error } = await supabase
        .from('problems')
        .select(`
          *,
          profiles ( id, full_name, role )
        `)
        .eq('id', id)
        .single();

      if (error) {
        if (error.code === 'PGRST116') { // PGRST116: "The result contains 0 rows"
          return null; // Not found is not an error in this context
        }
        console.error('Error fetching problem by ID:', error);
        throw error;
      }
      return data as ProblemWithProfile;
    },
    enabled: !!id, // Only run query if id is provided
  });
};